// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Protocol extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("network", Value.fromString(""));
    this.set("chainId", Value.fromString(""));
    this.set("contractVersion", Value.fromString(""));
    this.set("publicMarketCount", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("totalValueLocked", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("badDebt", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("uniqueTraders", Value.fromBigInt(BigInt.zero()));
    this.set("totalTrades", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Protocol entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Protocol entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Protocol", id.toString(), this);
    }
  }

  static load(id: string): Protocol | null {
    return changetype<Protocol | null>(store.get("Protocol", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get network(): string {
    let value = this.get("network");
    return value!.toString();
  }

  set network(value: string) {
    this.set("network", Value.fromString(value));
  }

  get chainId(): string {
    let value = this.get("chainId");
    return value!.toString();
  }

  set chainId(value: string) {
    this.set("chainId", Value.fromString(value));
  }

  get contractVersion(): string {
    let value = this.get("contractVersion");
    return value!.toString();
  }

  set contractVersion(value: string) {
    this.set("contractVersion", Value.fromString(value));
  }

  get publicMarketCount(): BigInt {
    let value = this.get("publicMarketCount");
    return value!.toBigInt();
  }

  set publicMarketCount(value: BigInt) {
    this.set("publicMarketCount", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get totalValueLocked(): BigDecimal {
    let value = this.get("totalValueLocked");
    return value!.toBigDecimal();
  }

  set totalValueLocked(value: BigDecimal) {
    this.set("totalValueLocked", Value.fromBigDecimal(value));
  }

  get badDebt(): BigDecimal {
    let value = this.get("badDebt");
    return value!.toBigDecimal();
  }

  set badDebt(value: BigDecimal) {
    this.set("badDebt", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get uniqueTraders(): BigInt {
    let value = this.get("uniqueTraders");
    return value!.toBigInt();
  }

  set uniqueTraders(value: BigInt) {
    this.set("uniqueTraders", Value.fromBigInt(value));
  }

  get totalTrades(): BigInt {
    let value = this.get("totalTrades");
    return value!.toBigInt();
  }

  set totalTrades(value: BigInt) {
    this.set("totalTrades", Value.fromBigInt(value));
  }
}

export class ProtocolHourly extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("totalValueLocked", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("badDebt", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("totalTrades", Value.fromBigInt(BigInt.zero()));
    this.set("cumulativeVolume", Value.fromBigDecimal(BigDecimal.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProtocolHourly entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ProtocolHourly entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ProtocolHourly", id.toString(), this);
    }
  }

  static load(id: string): ProtocolHourly | null {
    return changetype<ProtocolHourly | null>(store.get("ProtocolHourly", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get totalValueLocked(): BigDecimal {
    let value = this.get("totalValueLocked");
    return value!.toBigDecimal();
  }

  set totalValueLocked(value: BigDecimal) {
    this.set("totalValueLocked", Value.fromBigDecimal(value));
  }

  get badDebt(): BigDecimal {
    let value = this.get("badDebt");
    return value!.toBigDecimal();
  }

  set badDebt(value: BigDecimal) {
    this.set("badDebt", Value.fromBigDecimal(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get totalTrades(): BigInt {
    let value = this.get("totalTrades");
    return value!.toBigInt();
  }

  set totalTrades(value: BigInt) {
    this.set("totalTrades", Value.fromBigInt(value));
  }

  get cumulativeVolume(): BigDecimal {
    let value = this.get("cumulativeVolume");
    return value!.toBigDecimal();
  }

  set cumulativeVolume(value: BigDecimal) {
    this.set("cumulativeVolume", Value.fromBigDecimal(value));
  }
}

export class ProtocolDaily extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("totalValueLocked", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("badDebt", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("totalTrades", Value.fromBigInt(BigInt.zero()));
    this.set("cumulativeVolume", Value.fromBigDecimal(BigDecimal.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProtocolDaily entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ProtocolDaily entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ProtocolDaily", id.toString(), this);
    }
  }

  static load(id: string): ProtocolDaily | null {
    return changetype<ProtocolDaily | null>(store.get("ProtocolDaily", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get totalValueLocked(): BigDecimal {
    let value = this.get("totalValueLocked");
    return value!.toBigDecimal();
  }

  set totalValueLocked(value: BigDecimal) {
    this.set("totalValueLocked", Value.fromBigDecimal(value));
  }

  get badDebt(): BigDecimal {
    let value = this.get("badDebt");
    return value!.toBigDecimal();
  }

  set badDebt(value: BigDecimal) {
    this.set("badDebt", Value.fromBigDecimal(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get totalTrades(): BigInt {
    let value = this.get("totalTrades");
    return value!.toBigInt();
  }

  set totalTrades(value: BigInt) {
    this.set("totalTrades", Value.fromBigInt(value));
  }

  get cumulativeVolume(): BigDecimal {
    let value = this.get("cumulativeVolume");
    return value!.toBigDecimal();
  }

  set cumulativeVolume(value: BigDecimal) {
    this.set("cumulativeVolume", Value.fromBigDecimal(value));
  }
}

export class ProtocolWeekly extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("totalValueLocked", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("badDebt", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("totalTrades", Value.fromBigInt(BigInt.zero()));
    this.set("cumulativeVolume", Value.fromBigDecimal(BigDecimal.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProtocolWeekly entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ProtocolWeekly entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ProtocolWeekly", id.toString(), this);
    }
  }

  static load(id: string): ProtocolWeekly | null {
    return changetype<ProtocolWeekly | null>(store.get("ProtocolWeekly", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get totalValueLocked(): BigDecimal {
    let value = this.get("totalValueLocked");
    return value!.toBigDecimal();
  }

  set totalValueLocked(value: BigDecimal) {
    this.set("totalValueLocked", Value.fromBigDecimal(value));
  }

  get badDebt(): BigDecimal {
    let value = this.get("badDebt");
    return value!.toBigDecimal();
  }

  set badDebt(value: BigDecimal) {
    this.set("badDebt", Value.fromBigDecimal(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get totalTrades(): BigInt {
    let value = this.get("totalTrades");
    return value!.toBigInt();
  }

  set totalTrades(value: BigInt) {
    this.set("totalTrades", Value.fromBigInt(value));
  }

  get cumulativeVolume(): BigDecimal {
    let value = this.get("cumulativeVolume");
    return value!.toBigDecimal();
  }

  set cumulativeVolume(value: BigDecimal) {
    this.set("cumulativeVolume", Value.fromBigDecimal(value));
  }
}

export class Market extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("quoteToken", Value.fromBytes(Bytes.empty()));
    this.set("pool", Value.fromBytes(Bytes.empty()));
    this.set("feeRatio", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("baseAmount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("quoteAmount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberAdded", Value.fromBigInt(BigInt.zero()));
    this.set("timestampAdded", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Market entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Market entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Market", id.toString(), this);
    }
  }

  static load(id: string): Market | null {
    return changetype<Market | null>(store.get("Market", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    let value = this.get("quoteToken");
    return value!.toBytes();
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get feeRatio(): BigInt {
    let value = this.get("feeRatio");
    return value!.toBigInt();
  }

  set feeRatio(value: BigInt) {
    this.set("feeRatio", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get baseAmount(): BigDecimal {
    let value = this.get("baseAmount");
    return value!.toBigDecimal();
  }

  set baseAmount(value: BigDecimal) {
    this.set("baseAmount", Value.fromBigDecimal(value));
  }

  get quoteAmount(): BigDecimal {
    let value = this.get("quoteAmount");
    return value!.toBigDecimal();
  }

  set quoteAmount(value: BigDecimal) {
    this.set("quoteAmount", Value.fromBigDecimal(value));
  }

  get blockNumberAdded(): BigInt {
    let value = this.get("blockNumberAdded");
    return value!.toBigInt();
  }

  set blockNumberAdded(value: BigInt) {
    this.set("blockNumberAdded", Value.fromBigInt(value));
  }

  get timestampAdded(): BigInt {
    let value = this.get("timestampAdded");
    return value!.toBigInt();
  }

  set timestampAdded(value: BigInt) {
    this.set("timestampAdded", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get positions(): Array<string> {
    let value = this.get("positions");
    return value!.toStringArray();
  }

  set positions(value: Array<string>) {
    this.set("positions", Value.fromStringArray(value));
  }

  get openOrders(): Array<string> {
    let value = this.get("openOrders");
    return value!.toStringArray();
  }

  set openOrders(value: Array<string>) {
    this.set("openOrders", Value.fromStringArray(value));
  }
}

export class MarketDaily extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("quoteToken", Value.fromBytes(Bytes.empty()));
    this.set("pool", Value.fromBytes(Bytes.empty()));
    this.set("feeRatio", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("baseAmount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("quoteAmount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberAdded", Value.fromBigInt(BigInt.zero()));
    this.set("timestampAdded", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("market", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MarketDaily entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save MarketDaily entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("MarketDaily", id.toString(), this);
    }
  }

  static load(id: string): MarketDaily | null {
    return changetype<MarketDaily | null>(store.get("MarketDaily", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    let value = this.get("quoteToken");
    return value!.toBytes();
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get feeRatio(): BigInt {
    let value = this.get("feeRatio");
    return value!.toBigInt();
  }

  set feeRatio(value: BigInt) {
    this.set("feeRatio", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get baseAmount(): BigDecimal {
    let value = this.get("baseAmount");
    return value!.toBigDecimal();
  }

  set baseAmount(value: BigDecimal) {
    this.set("baseAmount", Value.fromBigDecimal(value));
  }

  get quoteAmount(): BigDecimal {
    let value = this.get("quoteAmount");
    return value!.toBigDecimal();
  }

  set quoteAmount(value: BigDecimal) {
    this.set("quoteAmount", Value.fromBigDecimal(value));
  }

  get blockNumberAdded(): BigInt {
    let value = this.get("blockNumberAdded");
    return value!.toBigInt();
  }

  set blockNumberAdded(value: BigInt) {
    this.set("blockNumberAdded", Value.fromBigInt(value));
  }

  get timestampAdded(): BigInt {
    let value = this.get("timestampAdded");
    return value!.toBigInt();
  }

  set timestampAdded(value: BigInt) {
    this.set("timestampAdded", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get market(): string {
    let value = this.get("market");
    return value!.toString();
  }

  set market(value: string) {
    this.set("market", Value.fromString(value));
  }
}

export class Deposited extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("collateralToken", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Deposited entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Deposited entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Deposited", id.toString(), this);
    }
  }

  static load(id: string): Deposited | null {
    return changetype<Deposited | null>(store.get("Deposited", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get collateralToken(): Bytes {
    let value = this.get("collateralToken");
    return value!.toBytes();
  }

  set collateralToken(value: Bytes) {
    this.set("collateralToken", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Withdrawn extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("collateralToken", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Withdrawn entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Withdrawn entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Withdrawn", id.toString(), this);
    }
  }

  static load(id: string): Withdrawn | null {
    return changetype<Withdrawn | null>(store.get("Withdrawn", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get collateralToken(): Bytes {
    let value = this.get("collateralToken");
    return value!.toBytes();
  }

  set collateralToken(value: Bytes) {
    this.set("collateralToken", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class PositionChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("exchangedPositionSize", Value.fromBigDecimal(BigDecimal.zero()));
    this.set(
      "exchangedPositionNotional",
      Value.fromBigDecimal(BigDecimal.zero())
    );
    this.set("fee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("openNotional", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("realizedPnl", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("positionSizeAfter", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("swappedPrice", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("entryPriceAfter", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("marketPriceAfter", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fromFunctionSignature", Value.fromBytes(Bytes.empty()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save PositionChanged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("PositionChanged", id.toString(), this);
    }
  }

  static load(id: string): PositionChanged | null {
    return changetype<PositionChanged | null>(store.get("PositionChanged", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get exchangedPositionSize(): BigDecimal {
    let value = this.get("exchangedPositionSize");
    return value!.toBigDecimal();
  }

  set exchangedPositionSize(value: BigDecimal) {
    this.set("exchangedPositionSize", Value.fromBigDecimal(value));
  }

  get exchangedPositionNotional(): BigDecimal {
    let value = this.get("exchangedPositionNotional");
    return value!.toBigDecimal();
  }

  set exchangedPositionNotional(value: BigDecimal) {
    this.set("exchangedPositionNotional", Value.fromBigDecimal(value));
  }

  get fee(): BigDecimal {
    let value = this.get("fee");
    return value!.toBigDecimal();
  }

  set fee(value: BigDecimal) {
    this.set("fee", Value.fromBigDecimal(value));
  }

  get openNotional(): BigDecimal {
    let value = this.get("openNotional");
    return value!.toBigDecimal();
  }

  set openNotional(value: BigDecimal) {
    this.set("openNotional", Value.fromBigDecimal(value));
  }

  get realizedPnl(): BigDecimal {
    let value = this.get("realizedPnl");
    return value!.toBigDecimal();
  }

  set realizedPnl(value: BigDecimal) {
    this.set("realizedPnl", Value.fromBigDecimal(value));
  }

  get positionSizeAfter(): BigDecimal {
    let value = this.get("positionSizeAfter");
    return value!.toBigDecimal();
  }

  set positionSizeAfter(value: BigDecimal) {
    this.set("positionSizeAfter", Value.fromBigDecimal(value));
  }

  get swappedPrice(): BigDecimal {
    let value = this.get("swappedPrice");
    return value!.toBigDecimal();
  }

  set swappedPrice(value: BigDecimal) {
    this.set("swappedPrice", Value.fromBigDecimal(value));
  }

  get entryPriceAfter(): BigDecimal {
    let value = this.get("entryPriceAfter");
    return value!.toBigDecimal();
  }

  set entryPriceAfter(value: BigDecimal) {
    this.set("entryPriceAfter", Value.fromBigDecimal(value));
  }

  get marketPriceAfter(): BigDecimal {
    let value = this.get("marketPriceAfter");
    return value!.toBigDecimal();
  }

  set marketPriceAfter(value: BigDecimal) {
    this.set("marketPriceAfter", Value.fromBigDecimal(value));
  }

  get fromFunctionSignature(): Bytes {
    let value = this.get("fromFunctionSignature");
    return value!.toBytes();
  }

  set fromFunctionSignature(value: Bytes) {
    this.set("fromFunctionSignature", Value.fromBytes(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class FundingUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("markTwap", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("indexTwap", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("dailyFundingRate", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FundingUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FundingUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FundingUpdated", id.toString(), this);
    }
  }

  static load(id: string): FundingUpdated | null {
    return changetype<FundingUpdated | null>(store.get("FundingUpdated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get markTwap(): BigDecimal {
    let value = this.get("markTwap");
    return value!.toBigDecimal();
  }

  set markTwap(value: BigDecimal) {
    this.set("markTwap", Value.fromBigDecimal(value));
  }

  get indexTwap(): BigDecimal {
    let value = this.get("indexTwap");
    return value!.toBigDecimal();
  }

  set indexTwap(value: BigDecimal) {
    this.set("indexTwap", Value.fromBigDecimal(value));
  }

  get dailyFundingRate(): BigDecimal {
    let value = this.get("dailyFundingRate");
    return value!.toBigDecimal();
  }

  set dailyFundingRate(value: BigDecimal) {
    this.set("dailyFundingRate", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class FundingPaymentSettled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("fundingPayment", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save FundingPaymentSettled entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FundingPaymentSettled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FundingPaymentSettled", id.toString(), this);
    }
  }

  static load(id: string): FundingPaymentSettled | null {
    return changetype<FundingPaymentSettled | null>(
      store.get("FundingPaymentSettled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get fundingPayment(): BigDecimal {
    let value = this.get("fundingPayment");
    return value!.toBigDecimal();
  }

  set fundingPayment(value: BigDecimal) {
    this.set("fundingPayment", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Trader extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("collateral", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("realizedPnl", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fundingPayment", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("liquidationFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("makerFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("totalPnl", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("badDebt", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Trader entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Trader entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Trader", id.toString(), this);
    }
  }

  static load(id: string): Trader | null {
    return changetype<Trader | null>(store.get("Trader", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get collateral(): BigDecimal {
    let value = this.get("collateral");
    return value!.toBigDecimal();
  }

  set collateral(value: BigDecimal) {
    this.set("collateral", Value.fromBigDecimal(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get realizedPnl(): BigDecimal {
    let value = this.get("realizedPnl");
    return value!.toBigDecimal();
  }

  set realizedPnl(value: BigDecimal) {
    this.set("realizedPnl", Value.fromBigDecimal(value));
  }

  get fundingPayment(): BigDecimal {
    let value = this.get("fundingPayment");
    return value!.toBigDecimal();
  }

  set fundingPayment(value: BigDecimal) {
    this.set("fundingPayment", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get liquidationFee(): BigDecimal {
    let value = this.get("liquidationFee");
    return value!.toBigDecimal();
  }

  set liquidationFee(value: BigDecimal) {
    this.set("liquidationFee", Value.fromBigDecimal(value));
  }

  get makerFee(): BigDecimal {
    let value = this.get("makerFee");
    return value!.toBigDecimal();
  }

  set makerFee(value: BigDecimal) {
    this.set("makerFee", Value.fromBigDecimal(value));
  }

  get totalPnl(): BigDecimal {
    let value = this.get("totalPnl");
    return value!.toBigDecimal();
  }

  set totalPnl(value: BigDecimal) {
    this.set("totalPnl", Value.fromBigDecimal(value));
  }

  get badDebt(): BigDecimal {
    let value = this.get("badDebt");
    return value!.toBigDecimal();
  }

  set badDebt(value: BigDecimal) {
    this.set("badDebt", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get positions(): Array<string> {
    let value = this.get("positions");
    return value!.toStringArray();
  }

  set positions(value: Array<string>) {
    this.set("positions", Value.fromStringArray(value));
  }

  get dayData(): Array<string> | null {
    let value = this.get("dayData");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set dayData(value: Array<string> | null) {
    if (!value) {
      this.unset("dayData");
    } else {
      this.set("dayData", Value.fromStringArray(<Array<string>>value));
    }
  }

  get referrerCode(): string | null {
    let value = this.get("referrerCode");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set referrerCode(value: string | null) {
    if (!value) {
      this.unset("referrerCode");
    } else {
      this.set("referrerCode", Value.fromString(<string>value));
    }
  }

  get refereeCode(): string | null {
    let value = this.get("refereeCode");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set refereeCode(value: string | null) {
    if (!value) {
      this.unset("refereeCode");
    } else {
      this.set("refereeCode", Value.fromString(<string>value));
    }
  }
}

export class Position extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("positionSize", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("openNotional", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("entryPrice", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("realizedPnl", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fundingPayment", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("liquidationFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("traderRef", Value.fromString(""));
    this.set("marketRef", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Position entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Position entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Position", id.toString(), this);
    }
  }

  static load(id: string): Position | null {
    return changetype<Position | null>(store.get("Position", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get positionSize(): BigDecimal {
    let value = this.get("positionSize");
    return value!.toBigDecimal();
  }

  set positionSize(value: BigDecimal) {
    this.set("positionSize", Value.fromBigDecimal(value));
  }

  get openNotional(): BigDecimal {
    let value = this.get("openNotional");
    return value!.toBigDecimal();
  }

  set openNotional(value: BigDecimal) {
    this.set("openNotional", Value.fromBigDecimal(value));
  }

  get entryPrice(): BigDecimal {
    let value = this.get("entryPrice");
    return value!.toBigDecimal();
  }

  set entryPrice(value: BigDecimal) {
    this.set("entryPrice", Value.fromBigDecimal(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get realizedPnl(): BigDecimal {
    let value = this.get("realizedPnl");
    return value!.toBigDecimal();
  }

  set realizedPnl(value: BigDecimal) {
    this.set("realizedPnl", Value.fromBigDecimal(value));
  }

  get fundingPayment(): BigDecimal {
    let value = this.get("fundingPayment");
    return value!.toBigDecimal();
  }

  set fundingPayment(value: BigDecimal) {
    this.set("fundingPayment", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get liquidationFee(): BigDecimal {
    let value = this.get("liquidationFee");
    return value!.toBigDecimal();
  }

  set liquidationFee(value: BigDecimal) {
    this.set("liquidationFee", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get traderRef(): string {
    let value = this.get("traderRef");
    return value!.toString();
  }

  set traderRef(value: string) {
    this.set("traderRef", Value.fromString(value));
  }

  get marketRef(): string {
    let value = this.get("marketRef");
    return value!.toString();
  }

  set marketRef(value: string) {
    this.set("marketRef", Value.fromString(value));
  }
}

export class PositionHistory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("positionSize", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("openNotional", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("entryPrice", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("realizedPnl", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fundingPayment", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("tradingFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("liquidationFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionHistory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save PositionHistory entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("PositionHistory", id.toString(), this);
    }
  }

  static load(id: string): PositionHistory | null {
    return changetype<PositionHistory | null>(store.get("PositionHistory", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get positionSize(): BigDecimal {
    let value = this.get("positionSize");
    return value!.toBigDecimal();
  }

  set positionSize(value: BigDecimal) {
    this.set("positionSize", Value.fromBigDecimal(value));
  }

  get openNotional(): BigDecimal {
    let value = this.get("openNotional");
    return value!.toBigDecimal();
  }

  set openNotional(value: BigDecimal) {
    this.set("openNotional", Value.fromBigDecimal(value));
  }

  get entryPrice(): BigDecimal {
    let value = this.get("entryPrice");
    return value!.toBigDecimal();
  }

  set entryPrice(value: BigDecimal) {
    this.set("entryPrice", Value.fromBigDecimal(value));
  }

  get realizedPnl(): BigDecimal {
    let value = this.get("realizedPnl");
    return value!.toBigDecimal();
  }

  set realizedPnl(value: BigDecimal) {
    this.set("realizedPnl", Value.fromBigDecimal(value));
  }

  get fundingPayment(): BigDecimal {
    let value = this.get("fundingPayment");
    return value!.toBigDecimal();
  }

  set fundingPayment(value: BigDecimal) {
    this.set("fundingPayment", Value.fromBigDecimal(value));
  }

  get tradingFee(): BigDecimal {
    let value = this.get("tradingFee");
    return value!.toBigDecimal();
  }

  set tradingFee(value: BigDecimal) {
    this.set("tradingFee", Value.fromBigDecimal(value));
  }

  get liquidationFee(): BigDecimal {
    let value = this.get("liquidationFee");
    return value!.toBigDecimal();
  }

  set liquidationFee(value: BigDecimal) {
    this.set("liquidationFee", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class PositionLiquidated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("liquidator", Value.fromBytes(Bytes.empty()));
    this.set("positionNotionalAbs", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("positionSizeAbs", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("liquidationFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionLiquidated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save PositionLiquidated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("PositionLiquidated", id.toString(), this);
    }
  }

  static load(id: string): PositionLiquidated | null {
    return changetype<PositionLiquidated | null>(
      store.get("PositionLiquidated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get liquidator(): Bytes {
    let value = this.get("liquidator");
    return value!.toBytes();
  }

  set liquidator(value: Bytes) {
    this.set("liquidator", Value.fromBytes(value));
  }

  get positionNotionalAbs(): BigDecimal {
    let value = this.get("positionNotionalAbs");
    return value!.toBigDecimal();
  }

  set positionNotionalAbs(value: BigDecimal) {
    this.set("positionNotionalAbs", Value.fromBigDecimal(value));
  }

  get positionSizeAbs(): BigDecimal {
    let value = this.get("positionSizeAbs");
    return value!.toBigDecimal();
  }

  set positionSizeAbs(value: BigDecimal) {
    this.set("positionSizeAbs", Value.fromBigDecimal(value));
  }

  get liquidationFee(): BigDecimal {
    let value = this.get("liquidationFee");
    return value!.toBigDecimal();
  }

  set liquidationFee(value: BigDecimal) {
    this.set("liquidationFee", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Maker extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("collectedFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Maker entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Maker entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Maker", id.toString(), this);
    }
  }

  static load(id: string): Maker | null {
    return changetype<Maker | null>(store.get("Maker", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get collectedFee(): BigDecimal {
    let value = this.get("collectedFee");
    return value!.toBigDecimal();
  }

  set collectedFee(value: BigDecimal) {
    this.set("collectedFee", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get openOrders(): Array<string> {
    let value = this.get("openOrders");
    return value!.toStringArray();
  }

  set openOrders(value: Array<string>) {
    this.set("openOrders", Value.fromStringArray(value));
  }
}

export class OpenOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("lowerTick", Value.fromBigInt(BigInt.zero()));
    this.set("upperTick", Value.fromBigInt(BigInt.zero()));
    this.set("baseAmount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("quoteAmount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("liquidity", Value.fromBigInt(BigInt.zero()));
    this.set("collectedFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set(
      "collectedFeeInThisLifecycle",
      Value.fromBigDecimal(BigDecimal.zero())
    );
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("makerRef", Value.fromString(""));
    this.set("marketRef", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OpenOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save OpenOrder entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("OpenOrder", id.toString(), this);
    }
  }

  static load(id: string): OpenOrder | null {
    return changetype<OpenOrder | null>(store.get("OpenOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get lowerTick(): BigInt {
    let value = this.get("lowerTick");
    return value!.toBigInt();
  }

  set lowerTick(value: BigInt) {
    this.set("lowerTick", Value.fromBigInt(value));
  }

  get upperTick(): BigInt {
    let value = this.get("upperTick");
    return value!.toBigInt();
  }

  set upperTick(value: BigInt) {
    this.set("upperTick", Value.fromBigInt(value));
  }

  get baseAmount(): BigDecimal {
    let value = this.get("baseAmount");
    return value!.toBigDecimal();
  }

  set baseAmount(value: BigDecimal) {
    this.set("baseAmount", Value.fromBigDecimal(value));
  }

  get quoteAmount(): BigDecimal {
    let value = this.get("quoteAmount");
    return value!.toBigDecimal();
  }

  set quoteAmount(value: BigDecimal) {
    this.set("quoteAmount", Value.fromBigDecimal(value));
  }

  get liquidity(): BigInt {
    let value = this.get("liquidity");
    return value!.toBigInt();
  }

  set liquidity(value: BigInt) {
    this.set("liquidity", Value.fromBigInt(value));
  }

  get collectedFee(): BigDecimal {
    let value = this.get("collectedFee");
    return value!.toBigDecimal();
  }

  set collectedFee(value: BigDecimal) {
    this.set("collectedFee", Value.fromBigDecimal(value));
  }

  get collectedFeeInThisLifecycle(): BigDecimal {
    let value = this.get("collectedFeeInThisLifecycle");
    return value!.toBigDecimal();
  }

  set collectedFeeInThisLifecycle(value: BigDecimal) {
    this.set("collectedFeeInThisLifecycle", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get makerRef(): string {
    let value = this.get("makerRef");
    return value!.toString();
  }

  set makerRef(value: string) {
    this.set("makerRef", Value.fromString(value));
  }

  get marketRef(): string {
    let value = this.get("marketRef");
    return value!.toString();
  }

  set marketRef(value: string) {
    this.set("marketRef", Value.fromString(value));
  }
}

export class LiquidityChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("maker", Value.fromBytes(Bytes.empty()));
    this.set("baseToken", Value.fromBytes(Bytes.empty()));
    this.set("quoteToken", Value.fromBytes(Bytes.empty()));
    this.set("lowerTick", Value.fromBigInt(BigInt.zero()));
    this.set("upperTick", Value.fromBigInt(BigInt.zero()));
    this.set("base", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("quote", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("liquidity", Value.fromBigInt(BigInt.zero()));
    this.set("quoteFee", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LiquidityChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save LiquidityChanged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("LiquidityChanged", id.toString(), this);
    }
  }

  static load(id: string): LiquidityChanged | null {
    return changetype<LiquidityChanged | null>(
      store.get("LiquidityChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    let value = this.get("quoteToken");
    return value!.toBytes();
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get lowerTick(): BigInt {
    let value = this.get("lowerTick");
    return value!.toBigInt();
  }

  set lowerTick(value: BigInt) {
    this.set("lowerTick", Value.fromBigInt(value));
  }

  get upperTick(): BigInt {
    let value = this.get("upperTick");
    return value!.toBigInt();
  }

  set upperTick(value: BigInt) {
    this.set("upperTick", Value.fromBigInt(value));
  }

  get base(): BigDecimal {
    let value = this.get("base");
    return value!.toBigDecimal();
  }

  set base(value: BigDecimal) {
    this.set("base", Value.fromBigDecimal(value));
  }

  get quote(): BigDecimal {
    let value = this.get("quote");
    return value!.toBigDecimal();
  }

  set quote(value: BigDecimal) {
    this.set("quote", Value.fromBigDecimal(value));
  }

  get liquidity(): BigInt {
    let value = this.get("liquidity");
    return value!.toBigInt();
  }

  set liquidity(value: BigInt) {
    this.set("liquidity", Value.fromBigInt(value));
  }

  get quoteFee(): BigDecimal {
    let value = this.get("quoteFee");
    return value!.toBigDecimal();
  }

  set quoteFee(value: BigDecimal) {
    this.set("quoteFee", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class PnlRealized extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PnlRealized entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save PnlRealized entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("PnlRealized", id.toString(), this);
    }
  }

  static load(id: string): PnlRealized | null {
    return changetype<PnlRealized | null>(store.get("PnlRealized", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class BadDebtHappened extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txHash", Value.fromBytes(Bytes.empty()));
    this.set("trader", Value.fromBytes(Bytes.empty()));
    this.set("amount", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("blockNumberLogIndex", Value.fromBigInt(BigInt.zero()));
    this.set("blockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BadDebtHappened entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save BadDebtHappened entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("BadDebtHappened", id.toString(), this);
    }
  }

  static load(id: string): BadDebtHappened | null {
    return changetype<BadDebtHappened | null>(store.get("BadDebtHappened", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get blockNumberLogIndex(): BigInt {
    let value = this.get("blockNumberLogIndex");
    return value!.toBigInt();
  }

  set blockNumberLogIndex(value: BigInt) {
    this.set("blockNumberLogIndex", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class TraderDayData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("trader", Value.fromString(""));
    this.set("date", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
    this.set("realizedPnl", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TraderDayData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TraderDayData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TraderDayData", id.toString(), this);
    }
  }

  static load(id: string): TraderDayData | null {
    return changetype<TraderDayData | null>(store.get("TraderDayData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get trader(): string {
    let value = this.get("trader");
    return value!.toString();
  }

  set trader(value: string) {
    this.set("trader", Value.fromString(value));
  }

  get date(): BigInt {
    let value = this.get("date");
    return value!.toBigInt();
  }

  set date(value: BigInt) {
    this.set("date", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get realizedPnl(): BigInt {
    let value = this.get("realizedPnl");
    return value!.toBigInt();
  }

  set realizedPnl(value: BigInt) {
    this.set("realizedPnl", Value.fromBigInt(value));
  }
}

export class TraderWeekData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("trader", Value.fromString(""));
    this.set("date", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
    this.set("realizedPnl", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TraderWeekData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TraderWeekData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TraderWeekData", id.toString(), this);
    }
  }

  static load(id: string): TraderWeekData | null {
    return changetype<TraderWeekData | null>(store.get("TraderWeekData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get trader(): string {
    let value = this.get("trader");
    return value!.toString();
  }

  set trader(value: string) {
    this.set("trader", Value.fromString(value));
  }

  get date(): BigInt {
    let value = this.get("date");
    return value!.toBigInt();
  }

  set date(value: BigInt) {
    this.set("date", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get realizedPnl(): BigInt {
    let value = this.get("realizedPnl");
    return value!.toBigInt();
  }

  set realizedPnl(value: BigInt) {
    this.set("realizedPnl", Value.fromBigInt(value));
  }
}

export class TraderMonthData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("trader", Value.fromString(""));
    this.set("date", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fee", Value.fromBigInt(BigInt.zero()));
    this.set("realizedPnl", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TraderMonthData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TraderMonthData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TraderMonthData", id.toString(), this);
    }
  }

  static load(id: string): TraderMonthData | null {
    return changetype<TraderMonthData | null>(store.get("TraderMonthData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get trader(): string {
    let value = this.get("trader");
    return value!.toString();
  }

  set trader(value: string) {
    this.set("trader", Value.fromString(value));
  }

  get date(): BigInt {
    let value = this.get("date");
    return value!.toBigInt();
  }

  set date(value: BigInt) {
    this.set("date", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get realizedPnl(): BigInt {
    let value = this.get("realizedPnl");
    return value!.toBigInt();
  }

  set realizedPnl(value: BigInt) {
    this.set("realizedPnl", Value.fromBigInt(value));
  }
}

export class ReferralCodeTraderDayData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("trader", Value.fromString(""));
    this.set("referralCodeDayData", Value.fromString(""));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fees", Value.fromBigDecimal(BigDecimal.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ReferralCodeTraderDayData entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ReferralCodeTraderDayData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ReferralCodeTraderDayData", id.toString(), this);
    }
  }

  static load(id: string): ReferralCodeTraderDayData | null {
    return changetype<ReferralCodeTraderDayData | null>(
      store.get("ReferralCodeTraderDayData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get trader(): string {
    let value = this.get("trader");
    return value!.toString();
  }

  set trader(value: string) {
    this.set("trader", Value.fromString(value));
  }

  get referralCodeDayData(): string {
    let value = this.get("referralCodeDayData");
    return value!.toString();
  }

  set referralCodeDayData(value: string) {
    this.set("referralCodeDayData", Value.fromString(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get fees(): BigDecimal {
    let value = this.get("fees");
    return value!.toBigDecimal();
  }

  set fees(value: BigDecimal) {
    this.set("fees", Value.fromBigDecimal(value));
  }
}

export class ReferralCodeDayData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("referralCode", Value.fromString(""));
    this.set("date", Value.fromBigInt(BigInt.zero()));
    this.set("tradingVolume", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("fees", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("newReferees", Value.fromStringArray(new Array(0)));
    this.set("activeReferees", Value.fromStringArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ReferralCodeDayData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ReferralCodeDayData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ReferralCodeDayData", id.toString(), this);
    }
  }

  static load(id: string): ReferralCodeDayData | null {
    return changetype<ReferralCodeDayData | null>(
      store.get("ReferralCodeDayData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get referralCode(): string {
    let value = this.get("referralCode");
    return value!.toString();
  }

  set referralCode(value: string) {
    this.set("referralCode", Value.fromString(value));
  }

  get date(): BigInt {
    let value = this.get("date");
    return value!.toBigInt();
  }

  set date(value: BigInt) {
    this.set("date", Value.fromBigInt(value));
  }

  get tradingVolume(): BigDecimal {
    let value = this.get("tradingVolume");
    return value!.toBigDecimal();
  }

  set tradingVolume(value: BigDecimal) {
    this.set("tradingVolume", Value.fromBigDecimal(value));
  }

  get fees(): BigDecimal {
    let value = this.get("fees");
    return value!.toBigDecimal();
  }

  set fees(value: BigDecimal) {
    this.set("fees", Value.fromBigDecimal(value));
  }

  get traderData(): Array<string> {
    let value = this.get("traderData");
    return value!.toStringArray();
  }

  set traderData(value: Array<string>) {
    this.set("traderData", Value.fromStringArray(value));
  }

  get newReferees(): Array<string> {
    let value = this.get("newReferees");
    return value!.toStringArray();
  }

  set newReferees(value: Array<string>) {
    this.set("newReferees", Value.fromStringArray(value));
  }

  get activeReferees(): Array<string> {
    let value = this.get("activeReferees");
    return value!.toStringArray();
  }

  set activeReferees(value: Array<string>) {
    this.set("activeReferees", Value.fromStringArray(value));
  }
}

export class ReferralCode extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("referrer", Value.fromString(""));
    this.set("createdAt", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ReferralCode entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ReferralCode entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ReferralCode", id.toString(), this);
    }
  }

  static load(id: string): ReferralCode | null {
    return changetype<ReferralCode | null>(store.get("ReferralCode", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get referrer(): string {
    let value = this.get("referrer");
    return value!.toString();
  }

  set referrer(value: string) {
    this.set("referrer", Value.fromString(value));
  }

  get referees(): Array<string> {
    let value = this.get("referees");
    return value!.toStringArray();
  }

  set referees(value: Array<string>) {
    this.set("referees", Value.fromStringArray(value));
  }

  get createdAt(): BigInt {
    let value = this.get("createdAt");
    return value!.toBigInt();
  }

  set createdAt(value: BigInt) {
    this.set("createdAt", Value.fromBigInt(value));
  }

  get dayData(): Array<string> | null {
    let value = this.get("dayData");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set dayData(value: Array<string> | null) {
    if (!value) {
      this.unset("dayData");
    } else {
      this.set("dayData", Value.fromStringArray(<Array<string>>value));
    }
  }

  get vipTier(): string | null {
    let value = this.get("vipTier");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set vipTier(value: string | null) {
    if (!value) {
      this.unset("vipTier");
    } else {
      this.set("vipTier", Value.fromString(<string>value));
    }
  }

  get vipSince(): BigInt | null {
    let value = this.get("vipSince");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set vipSince(value: BigInt | null) {
    if (!value) {
      this.unset("vipSince");
    } else {
      this.set("vipSince", Value.fromBigInt(<BigInt>value));
    }
  }

  get registeredOnChain(): boolean {
    let value = this.get("registeredOnChain");
    return value!.toBoolean();
  }

  set registeredOnChain(value: boolean) {
    this.set("registeredOnChain", Value.fromBoolean(value));
  }
}
